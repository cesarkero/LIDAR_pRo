file_name_proceso <- paste(output.folder, "\\", "archivos_procesados.csv", sep="")
write.csv2(tabla0, file = file_name_proceso, row.names=F, na="")
#
# #____________________________________________________________________________
# #------------------------------------------------------
# #proceso de parallel para windows NO FUNCIONA TODAVIA (es mas lento)
# no_cores <- detectCores() - 1 # Calculate the number of cores
# cl <- makeCluster(no_cores, type="SOCK") # Initiate cluster
#
# #export objects and functions
# clusterExport(cl=cl, objects())
# clusterExport(cl=cl, as.list(ls()),
#               envir=environment())
# l2 <- parLapply(cl,
#                 files,
#                 GPXTool,
#                 PPEEbuffer = PPEE25m)
# stopCluster(cl)
#
#
# #-----------------------------------------------------------------------
# #benchmark de GPXTool -- NO FUNCIONA PORQUE AUN NO ESTA PARLAPPLY LISTO
# benchmark("lapply" = {l1 <-  lapply(files,
#                                     GPXTool,
#                                     PPEEbuffer = PPEE25m)},
#           "parLapply" = {
#               #proceso de parallel para windows NO FUNCIONA TODAVIA
#               no_cores <- detectCores() - 1 # Calculate the number of cores
#               cl <- makeCluster(no_cores, type="SOCK") # Initiate cluster
#
#               #export objects and functions
#               clusterExport(cl=cl, objects())
#               clusterExport(cl=cl, as.list(ls()),
#                             envir=environment())
#               l2 <- parLapply(cl,
#                               files,
#                               GPXTool,
#                               PPEEbuffer = PPEE25m)
#               stopCluster(cl)
#           },
#           replications = 5,
#           columns = c("test", "replications", "elapsed")
# )
files[53]
GPXTool[53, PPEEbuffer = PPEE25m]
GPXTool(53, PPEEbuffer = PPEE25m)
GPXTool(files[53], PPEEbuffer = PPEE25m)
GPXTool(files[52], PPEEbuffer = PPEE25m)
GPXTool(files[53], PPEEbuffer = PPEE25m)
GPXTool(files[54], PPEEbuffer = PPEE25m)
GPXTool(files[50], PPEEbuffer = PPEE25m)
GPXTool(files[55], PPEEbuffer = PPEE25m)
l1 <- lapply(files, GPXTool, PPEEbuffer = PPEE25m)
l1
GPXTool(files[52], PPEEbuffer = PPEE25m)
l1 <- lapply(files, GPXTool, PPEEbuffer = PPEE25m)
l1 <- tryCatch(lapply(files, GPXTool, PPEEbuffer = PPEE25m), error = function(e) NULL )
l1 <- tryCatch(lapply(files, GPXTool, PPEEbuffer = PPEE25m), error = function(e) NULL )
l1
GPXTool(files[52], PPEEbuffer = PPEE25m)
tryCatch(GPXTool(files[52], PPEEbuffer = PPEE25m), error = function(e) NULL )
tryCatch(GPXTool(files[51], PPEEbuffer = PPEE25m), error = function(e) NULL )
tryCatch(GPXTool(files[52], PPEEbuffer = PPEE25m), error = function(e) NULL )
tryCatch(GPXTool(files[53], PPEEbuffer = PPEE25m), error = function(e) NULL )
files
tryCatch(GPXTool(files[200], PPEEbuffer = PPEE25m), error = function(e) NULL )
tryCatch(GPXTool(files[199], PPEEbuffer = PPEE25m), error = function(e) NULL )
tryCatch(GPXTool(files[180], PPEEbuffer = PPEE25m), error = function(e) NULL )
tryCatch(GPXTool(files[180], PPEEbuffer = PPEE25m), error = function(e) NULL )
for (i in 1:length(files)){
tryCatch(GPXTool(files[i], PPEEbuffer = PPEE25m), error = function(e) NULL )
}
for (i in 1:length(files)){
print (i)
tryCatch(GPXTool(files[i], PPEEbuffer = PPEE25m), error = function(e) NULL )
}
GPXTool(files[176], PPEEbuffer = PPEE25m)
path <- files[176]
gpxName <- tools::file_path_sans_ext(basename(path)) #base filename
gpx <- plotKML::readGPX(path, metadata=F, bounds=F, waypoints=F, tracks = T, routes= F) #read gpx file
try(plotKML::readGPX(path),silent=T)
path <- files[206]
gpx <- plotKML::readGPX(path, metadata=F, bounds=F, waypoints=F, tracks = T, routes= F) #read gpx file
class(try(plotKML::readGPX(path),silent=T)) == "try-error"
path <- files[176]
class(try(plotKML::readGPX(path),silent=T)) == "try-error"
path <- files[206]
class(try(plotKML::readGPX(path),silent=T)) == "try-error"
class(tryCathc(plotKML::readGPX(path),silent=T)) == "try-error"
class(tryCatch(plotKML::readGPX(path),silent=T)) == "try-error"
path <- files[206]
gpx <- plotKML::readGPX(path, metadata=F, bounds=F, waypoints=F, tracks = T, routes= F) #read gpx file
try(plotKML::readGPX(path),silent=T)
?try
try(plotKML::readGPX(path),silent=T)
plotKML::readGPX(path)
try(plotKML::readGPX(path),silent=T)
class(try(plotKML::readGPX(path),silent=T)) == "try-error"
class(try(plotKML::readGPX(path),silent=T)) == "try-error"
try(plotKML::readGPX(path),silent=T) == "Document is empty"
class(try(plotKML::readGPX(path),silent=T)) == "try-error" == "Document is empty"
#introducir funcion test para evitar que lapply se pare
l1 <- lapply(files, GPXTool, PPEEbuffer = PPEE25m)
GPXTool(files, PPEEbuffer = PPEE25m)
source("C:/GitHub/AdantiaTools/00_functions.R")
#------------------------------------------------------------------
#TRACK PROCESS
files <- list.files(g.folder, pattern="*.gpx", full.names=T, recursive = T) #creates a list of files
source("C:/GitHub/AdantiaTools/00_functions.R")
#PARAMETROS
g.folder <- choose.dir(default = "C:\\GitHub\\AdantiaTools\\02_GPXTool\\gpx",
caption = "Select folder with gpx files:")
output.folder <- choose.dir(default = "C:\\GitHub\\AdantiaTools\\02_GPXTool\\output",
caption = "Select output folder")
PPEE25m <- gBuffer(PPEE <- readOGR(choose.dir(default = "C:\\GitHub\\AdantiaTools\\000_GEO\\PPEE",
caption = "Select folder with PPEE.shp (points):"),
'PPEE'),
byid= T, width = 25, quadsegs=10) # create buffer 25m by id
AtributosPPEE <- c("Cod_aero","Aero","Cod_parque","minTime","maxTime","tiempo_s",
"len","tecnico","filepath")
#------------------------------------------------------------------
#TRACK PROCESS
files <- list.files(g.folder, pattern="*.gpx", full.names=T, recursive = T) #creates a list of files
GPXTool(files, PPEEbuffer = PPEE25m)
gpxName <- tools::file_path_sans_ext(basename(path)) #base filename
# OUTPUT
#merge all valid shp in the list
l1.shp <- pblapply(l1, '[[', 1) ; l1.shp <- l1.shp[!is.na(l1.shp)] #list of shp without NA values
source("C:/GitHub/AdantiaTools/00_functions.R")
#PARAMETROS
g.folder <- choose.dir(default = "C:\\GitHub\\AdantiaTools\\02_GPXTool\\gpx",
caption = "Select folder with gpx files:")
output.folder <- choose.dir(default = "C:\\GitHub\\AdantiaTools\\02_GPXTool\\output",
caption = "Select output folder")
PPEE25m <- gBuffer(PPEE <- readOGR(choose.dir(default = "C:\\GitHub\\AdantiaTools\\000_GEO\\PPEE",
caption = "Select folder with PPEE.shp (points):"),
'PPEE'),
byid= T, width = 25, quadsegs=10) # create buffer 25m by id
AtributosPPEE <- c("Cod_aero","Aero","Cod_parque","minTime","maxTime","tiempo_s",
"len","tecnico","filepath")
#------------------------------------------------------------------
#TRACK PROCESS
files <- list.files(g.folder, pattern="*.gpx", full.names=T, recursive = T) #creates a list of files
#------------------------------------------
#Proceso lapply monitorizado basado en pbapply
l1 <- pblapply(files[1:50], GPXTool, PPEEbuffer = PPEE25m)
# OUTPUT
#merge all valid shp in the list
l1.shp <- pblapply(l1, '[[', 1) ; l1.shp <- l1.shp[!is.na(l1.shp)] #list of shp without NA values
shp0 <- EmptySLDF(AtributosPPEE) #creates empty SLDF from names
l1.shp
rbindlist(l1.shp)
if("data.table" %in% rownames(installed.packages()) == FALSE) {install.packages("data.table")}
library(data.table)
rbindlist(l1.shp)
clas(l1.shp)
class(l1.shp)
class(l1.shp[[1]])
rbind(l1.shp[[1]],l1.shp[[2]])
l1.shp[1]
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
l1.shp
l1.shp <- pblapply(l1.shp, '[[', 1)
l1.shp
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
l1.shp <- pblapply(l1.shp, '[', 1)
l1.shp
l1.shp[1]
class(l1.shp)
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
class(l1.shp)
class(l1.shp[1])
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
class(l1.shp[1])
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
l1.shp <- pblapply(l1.shp, '[', 1)
class(l1.shp[1])
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
class(l1.shp[[1]])
l1.shp <- pblapply(l1.shp, '[', 1)
class(l1.shp[[1]])
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
list(l1[[1]], l1[[2]])
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1[[1]]
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1[[1]][[1]]
list(l1[[1]][[1]], l1[[2]][[1]])
l1.shp <- pblapply(l1, '[[', 1)
l1.shp
list(l1[[1]][[1]], l1[[2]][[1]])
class(list(l1[[1]][[1]], l1[[2]][[1]]))
class(l1.shp)
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
l1.shp <- l1.shp[!is.na(l1.shp)] #list of shp without NA values
rbind(l1.shp[[1]],l1.shp[[2]])
l1.shp[1]
l1.shp[[1]]
l1.shp[1]
l1.shp[[1]]
class(l1.shp[1])
class(l1.shp[[1]])
l1.shp <- pblapply(l1, '[[', 1)
class(l1.shp[1])
class(l1.shp[[1]])
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
l1.shp
l1.shp <- pblapply(l1, '[[', 1)
l1.shp
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
summary(l1.shp)
l1.shp <- pblapply(l1, '[[', 1)
summary(l1.shp)
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
summary(l1.shp)
l1.shp <- pblapply(l1, '[', 1)
summary(l1.shp)
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
summary(l1.shp)
l1.shp <- l1.shp[!is.na(l1.shp)] #list of shp without NA values
class(l1.shp[1])
class(l1.shp[[1]])
l1.shp[[]]
l1.shp[[*]]
l1.shp[
l1.shp[]
l1.shp[1]
source("C:/GitHub/AdantiaTools/00_functions.R")
#PARAMETROS
g.folder <- choose.dir(default = "C:\\GitHub\\AdantiaTools\\02_GPXTool\\gpx",
caption = "Select folder with gpx files:")
output.folder <- choose.dir(default = "C:\\GitHub\\AdantiaTools\\02_GPXTool\\output",
caption = "Select output folder")
PPEE25m <- gBuffer(PPEE <- readOGR(choose.dir(default = "C:\\GitHub\\AdantiaTools\\000_GEO\\PPEE",
caption = "Select folder with PPEE.shp (points):"),
'PPEE'),
byid= T, width = 25, quadsegs=10) # create buffer 25m by id
AtributosPPEE <- c("Cod_aero","Aero","Cod_parque","minTime","maxTime","tiempo_s",
"len","tecnico","filepath")
#------------------------------------------------------------------
#TRACK PROCESS
files <- list.files(g.folder, pattern="*.gpx", full.names=T, recursive = T) #creates a list of files
#------------------------------------------
#Proceso lapply monitorizado basado en pbapply
l1 <- pblapply(files[1:50], GPXTool, PPEEbuffer = PPEE25m)
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[', 1)
summary(l1.shp)
# OUTPUT
#merge all valid shp in the list
#CORREGIR NO HAY UN ELEMENTO EN CADA POSICION DE LA LISTA SI NO UNA LISTA DE UN ELEMENTO EN CADA POSICION
l1.shp <- pblapply(l1, '[[', 1)
summary(l1.shp)
l1.shp <- l1.shp[!is.na(l1.shp)] #list of shp without NA values
class(l1.shp[1])
class(l1.shp[[1]])
#read functions depending on OS
ifelse(Sys.info()[[1]] == "Windows",
source("C:/GitHub/AdantiaTools/00_functions.R"),
source("/data/home/cesarkero/Dropbox/Azure/00_functions.R"))
f <- function (x) {return <- (x^2)^2}
f.list <- c(50000000:100000000)
#read functions depending on OS
ifelse(Sys.info()[[1]] == "Windows",
source("C:/GitHub/AdantiaTools/00_functions.R"),
source("/data/home/cesarkero/Dropbox/Azure/00_functions.R"))
f <- function (x) {return <- (x^2)^2}
f.list <- c(50000000:100000000)
f.list <- list(50000000:100000000)
f.list <- list(50000000:100000000)
# pblapply
f1 <-pblapply(f.list,f)
# parLapply
no_cores <- detectCores() - 1 # Calculate the number of cores
cl <- makeCluster(no_cores, type="SOCK") # Initiate cluster
l1 <- parLapply(cl, f.list, f)
stopCluster(cl)
f <- function (x) {return <- (x^2)^2}
f.list <- list(50000000:100000000)
# pblapply
f1 <-pblapply(f.list,f)
# parLapply
no_cores <- detectCores() - 1 # Calculate the number of cores
cl <- makeCluster(no_cores, type="SOCK") # Initiate cluster
f2 <- parLapply(cl, f.list, f)
stopCluster(cl)
f <- function (x) {return <- (x^2)^2}
f.list <- list(50000000:200000000)
# pblapply
f1 <-pblapply(f.list,f)
# parLapply
no_cores <- detectCores() - 1 # Calculate the number of cores
cl <- makeCluster(no_cores, type="SOCK") # Initiate cluster
f2 <- parLapply(cl, f.list, f)
stopCluster(cl)
#_______________________________________________________________________________
# CHOOSE DIRECTORY
choose_gpx_folder = function(caption = 'Select _______ file/directory:') {
if (Sys.info()[[1]] == "Windows") {
choose.dir(default = "C:\\GitHub\\AdantiaTools\\02_GPXTool\\gpx",
caption = caption)
} else {
ifelse(Sys.info()[[1]] == "Linux", rstudioapi::choose_dir(caption = caption),
tk_choose.dir(caption = caption))
}
}
grep('gpx', t1)
t1 <- 'Select gpx directory:'
grep('gpx', t1)
t1 <- 'Select Gpx directory:'
grep('gpx', t1)
grep('gpx', t1, value=T)
t1 <- 'Select gpx directory:'
grep('gpx', t1, value=T)
?grep
t1 <- 'Select gpx directory:'
grep('gpx', t1, ignore.case = T)
grep('gpx', t1, ignore.case = T, perl = T)
t1 <- 'Select .gpx directory:'
grep('gpx', t1, ignore.case = T)
t1 <- 'Select .Gpx directory:'
grep('gpx', t1, ignore.case = T)
t1 <- 'Select .Gapx directory:'
grep('gpx', t1, ignore.case = T)
grep('gpx', t1, ignore.case = T) >= 1
grep('gpx', t1, ignore.case = T) >= 1
grep('gpx', t1, ignore.case = T)
t1 <- 'Select .Gpx directory:'
grep('gpx', t1, ignore.case = T)
grep('gpx', t1, ignore.case = T) >=1
sys.time(9)
sys.time()
sys.time()
sys.time
Sys.time()
t1<-Sys.time()
t1-t0
t0<-Sys.time()
t1<-Sys.time()
t1-t0
source("00_F&L.R")
source("00_F&L.R")
source("00_Base.R")
source("00_Base.R")
getwd()
source("00_Base.R")
source("00_Base.R")
lasdir <- choose_folder(caption = "Select las dir:") #select dir to las or laz
output <- choose_folder(caption = "Select output dir:") #output dir
cat <- catalog(lasdir)
cores(cat) <- 3
buffer(cat) <- 20
source("00_Base.R")
setwd("C:/GitHub/LIDAR_pRo")
source("00_Base.R")
lasdir <- choose_folder(caption = "Select las dir:") #select dir to las or laz
output <- choose_folder(caption = "Select output dir:") #output dir
cat <- catalog(lasdir)
cores(cat) <- 3
buffer(cat) <- 20
cat
#-------------------------------------------------------------------------------
#Como usar catalog_apply con la funcion TSE
catalog_apply(cat, TSE, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output, filterLas = "-drop_z_below 0")
cat
cat[1]
str(cat)
cat$filename
cat@filename
cat@data$filename
cat <- catalog(lasdir)
cores(cat) <- 3
buffer(cat) <- 20
cat@data$`Max X`
cat@data$`Max X`[1]
cat@data$`Max X`[1] - cat@data$`Min X`[1]
round(cat@data$`Max X`[1] - cat@data$`Min X`[1])
?catalog
tiling_size(cat) <- round(cat@data$`Max X`[1] - cat@data$`Min X`[1])
cat
plot(cat)
source("00_Base.R")
#Crear catálogo - hacer que los clusters coincidan con las dimensiones de las teselas
#esto sirve para que haya los mismos archivos que procesos
cat <- catalog(lasdir)
cores(cat) <- 3
buffer(cat) <- 20
tiling_size(cat) <- round(cat@data$`Max X`[1] - cat@data$`Min X`[1])
#-------------------------------------------------------------------------------
#Como usar catalog_apply con la funcion TSE
catalog_apply(cat, TSE, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output, filterLas = "-drop_z_below 0")
#-------------------------------------------------------------------------------
#Como usar catalog_apply con la funcion TSE
catalog_apply(cat, TSEcatalog, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output, filterLas = "-drop_z_below 0")
cat@data$filename
??catalog_apply
source("00_Base.R")
#-------------------------------------------------------------------------------
#Como usar catalog_apply con la funcion TSE
catalog_apply(cat, TSEcatalog, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output, filterLas = "-drop_z_below 0")
cat@data$filename[|]
cat@data$filename[1]
source("00_Base.R")
#-------------------------------------------------------------------------------
#Como usar catalog_apply con la funcion TSE
catalog_apply(cat, TSEcatalog, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output, filterLas = "-drop_z_below 0")
?catalog
str(cata)
str(cat)
source("00_Base.R")
#-------------------------------------------------------------------------------
#Como usar catalog_apply con la funcion TSE
catalog_apply(cat, TSEcatalog, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output, filterLas = "-drop_z_below 0")
lascat
lascat@data
cat
cat@data
cat@data$`filename`
cat@data$`filename`[1]
class(cat@data$`filename`[1])
source("00_Base.R")
#-------------------------------------------------------------------------------
#Como usar catalog_apply con la funcion TSE
catalog_apply(cat, TSEcatalog, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output, filterLas = "-drop_z_below 0")
catalog_apply(cat,grid_terrain)
catalog_apply(cat,grid_terrain, res=10, method="delaunay")
catalog_apply(cat,grid_terrain, res=10, method = "knnidw", k = 5, p = 2)
catalog_apply(cat,grid_terrain, res=10, method = "knnidw", k = 5, p = 2)
catalog_apply(cat,area)
a <- catalog_apply(cat,area)
a
#hillshade ( from raster)
hs <- function (x, alt = 40, az = 270) {
slope = terrain(x, opt='slope')
aspect = terrain(x, opt='aspect')
hs = hillShade(slope, aspect, alt, az)
return (hs)
}
source("00_Base.R")
catalog_apply(cat, TSEcatalog, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output)
source("00_Base.R")
catalog_apply(cat, TSEcatalog, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output)
source("00_Base.R")
lasdir <- choose_folder(caption = "Select las dir:") #select dir to las or laz
output <- choose_folder(caption = "Select output dir:") #output dir
#Crear catálogo - hacer que los clusters coincidan con las dimensiones de las teselas
#esto sirve para que haya los mismos archivos que procesos
#ojo porque no se ha encontrado como filtrar valores en el catalogo
cat <- catalog(lasdir)
cores(cat) <- 3
buffer(cat) <- 20
tiling_size(cat) <- round(cat@data$`Max X`[1] - cat@data$`Min X`[1])
rasters <- catalog_apply(cat, TSEcatalog, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output)
output_files(cat) <- output
lidR
?lidR
??lidR
devtools::install_github("Jean-Romain/rlas")
devtools::install_github("Jean-Romain/lidR")
rasters <- catalog_apply(cat, TSEcatalog, res = 1, method = "knnidw", epsg = "+init=epsg:25829",
output = output)
